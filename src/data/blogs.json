{
  "blogs": [
    {
      "id": "traction-control-pid",
      "title": "Building a PID Controller For Traction Control",
      "date": "2025-01-11",
      "author": "Emad Rahman",
      "excerpt": "Deep dive into developing a PID-based traction control system for FSAE racing, covering vehicle dynamics, slip ratio optimization, and Simulink modeling.",
      "content": "# Building a PID Controller For Traction Control\n\n![Comparison of car trajectories with and without traction control](/img/traction-control/image.png|225px|float-right)\n\nImagine driving in icy conditions during the winter or in the middle of heavy rainfall. Most of us would automatically drive much slower to prevent our car from slipping. Traction control is a mode that most cars have (and in fact, is on by default) that **prevents excessive slip** by reducing motor/engine torque or limiting it.\n\nA car's **slip ratio** is how much faster a car's wheels are moving vs. the vehicle itself. To understand how slip works, you need to understand how a car uses torque.\n\n[clear]\n\n## Car Torque Mechanics\n\n[tldr]**TLDR:** Slip is how much faster the wheels go as opposed to the vehicle. Traction Control keeps slip in a sweet spot, where acceleration is maximized.[/tldr]\n\n![Rear-wheel drive system diagram](/img/traction-control/download.jpg|400px|center|bg-muted|Rear-Wheel Drive System)\n\nWhen a car's engine/motor outputs torque, it needs to be transferred through a torque converter, then to the transmission where it gets multiplied by gear ratios, and finally through a driveshaft to get to the rear wheels. The differential and axle transfer the torque to the wheels.\n\n![Diagram showing torque on axle turning wheel](/img/traction-control/image-201.png|321px|float-right|bg-muted-p-2)\n\nWhat is interesting is what actually causes propulsion in cars. One would think that rotational torque would directly move the car forward, but that is not really the case. If you think about it, a car's wheels are really providing a **tangential force that is in the opposite direction of where you want the car to drive**. The car pushes the road backwards essentially. However, due to Newton's 3rd law, the road provides an equal and opposite reaction force, and this pushes the car forward. We call this the **static friction force** at the **contact patch** of the tire.\n\n[clear]\n\nWhat is the contact patch? Well, that is the area of the road where the tire makes direct contact with it. The tire will deform at the contact patch, which is crucial for the amount of forward force it will output. When the tires are moving at the exact same speed as the vehicle, we do not have deformation or any shear stress, and the static friction force is **0**. We need some slip for there to be deformation at the contact patch, which will maximize static friction.\n\n[image-stack-right|w-72]\n![Wheel spinning with smoke](/img/traction-control/image-202.png|288px)\n![Friction vs slip ratio graph](/img/traction-control/image-203.png|247px|bg-white|Friction vs Slip Ratio)\n[/image-stack-right]\n\nThere is a maximum static friction point that is equal to the **coefficient of friction** x **weight**, and when we exceed this force, tires begin to slide and instead use kinetic friction. Since the tire patching is now sliding, the tires drag across the road, converting valuable torque into heat energy instead of forward/lateral force. Kinetic friction is also much weaker than static friction, causing less forward force to generate.\n\nTherefore, we have a certain **sweet spot** of slip around **5-20%**. This allows for deformation and internal shear stress, which can maximize static friction force. The point of traction control is to keep slip at a **target slip %**, which will always allow for the maximum torque efficiency. In a racecar like what UWFE builds for FSAE comps, the point of TC is to reduce the need for drivers to meticulously control their usage of the torque pedal to avoid skidding. It would allow drivers to accelerate efficiently from launch, round corners with ease, and more.\n\n[clear]\n\n## Making a Traction Control Model\n\n[image-stack-right|w-60]\n![Wheel assembly with speed sensor](/img/traction-control/image-204.png|240px)\n![Rear wheel assembly with speed sensor](/img/traction-control/image-205.png|240px)\n[/image-stack-right]\n\nOur Vehicle Control Unit is responsible for running the traction control algorithm when it is configured. Basically, our vehicle has hall-effect sensors (**right image**) in the front of our car and wheel encoders at the back.\n\nThese values that the sensors receive are sent to the VCU, which runs the traction control algorithm every **35ms**, which receives the measurements, calculates the slip percentage seen at the rear wheels, and calculates a gain to apply using the PID controller that will adjust the torque limit of our car.\n\nThe torque limit will cap our torque at a certain value so that regardless of how hard the driver hits the gas, it will not output any more torque. Initially, our **torque limit** is **200Nm** which is close to the max of the inverter unit itself, but over time, what should happen is that the torque limit adjusts to be at a level where this max torque yields optimal slip %.\n\nKeep in mind, that there is probably a different slip percentage required depending on if you are going from launch, hard-turning, slippery conditions, etc. For this, I am focused on straightline/launch acceleration only.\n\n[clear]\n\nBased on this information, I built my traction controller to model this algorithm. In simulink, you are able to model traction control using a PID controller. The simulink model contains these key parts:\n\n![Simulink model showing slip target feedback control](/img/traction-control/image-206.png|710px|bg-white-p-4)\n\n[ordered-list-spaced-3]\n1. **A PID Controller** → Takes an error value and outputs an adjusted value to be inputted into the plant.\n2. **A plant model** → Takes the inputted value and mimics the actual real-life system to convert the input into a realistic output. Example: Taking a torque command and outputting wheel speeds, taking in a command to turn a robot and outputting how much it actually spins.\n3. **A feedback path** → A feedback path will take the plant output and feed it back into the PID loop.\n4. **An error sum** → The error will use this feedback, calculate the remaining error from the desired output, and send it back to the PID controller.\n[/ordered-list-spaced-3]\n\nIn my case, most of this is trivial, except for actually making the plant. Remember, on the actual car we have sensors that feed values to the VCU, but simulating the algorithm would not let us access sensor data since we aren't on the car. Therefore, we actually need to use good ol' fashioned physics to simulate a car in order to convert a torque output to vehicle and wheel speeds.\n\n![Detailed Simulink plant model](/img/traction-control/image-207.png|710px|bg-white-p-2|Plant Model: Wheel Speed Calcs, Vehicle Speed Calcs, Slip Calculation)\n\nTo get wheel speeds, I used **Newton's second law of rotational motion**, where the net external torque on a rigid body is equal to its moment of inertia multiplied by its angular acceleration, expressed as **Στ = Iα**, where τ is torque, I is inertia, and α is acceleration. We can integrate for speed.\n\nTo get vehicle speeds, we treat the whole vehicle as one point and apply all the main forces seen in a car's **FBD**; **longitudinal force, drag, and rolling resistance**. Then divide by mass and integrate for vehicle speed. We can then get slip by finding the ratio of wheel speed to vehicle speed and feed that back in to the error sum.\n\nA big pain point was finding out how I was going to calculate how much longitudinal force was experienced at the tires. Longitudinal force does not have any linear relationship in a car, and it is very hard to simulate it without having measured data to make a magic-formula relationship. Our car has not had its hall-effect sensors plugged in for a while now, so I had no access to data.\n\nWhat I ended up doing was creating an approximate **linear model** by calculating the static friction limit at the max possible ideal slip, which serves as the max longitudinal force (which we discussed in the vehicle dynamics section). Then I fed back the current slip to scale the longitudinal force that way.\n\n## Tuning a PID Controller\n\nA PID controller has 3 main parts to it, and they all have their own uses.\n\n![PID controller block diagram](/img/traction-control/image-208.png|710px|bg-white-p-4|PID Controller Block Diagram)\n\n[ordered-list-spaced-4]\n1. **P → Proportional;** The basic form of a PID uses P to apply a **gain** to your error to output a new command. For example, if you are 10 meters away from your target destination, your robot with a P of 10 will walk at a speed of 100, but once it is 1 meter away from its destination, it goes down to a speed of 10. When it reaches its destination, it stops moving. This is great and all, but it doesn't work in every situation. For our car, we don't want the motors to **stop** outputting torque. We need it to **maintain** its torque limit when it reaches its target slip.\n\n2. **I → Integral;** The integral portion of PID will integrate your total error as we continue getting the error closer to 0. That way, when the model actually reaches 0 error, even though the P controller shuts off, the integrator will carry on and **maintain** its current output. However, we can also face issues with this because with a high gain on the integrator, we can quite easily **overshoot** to actually have negative error, and it will take time to come back down.\n\n3. **D → Derivative;** The derivative of a PID controller takes into account how quickly the error is changing and will output an adjusted value to **reduce** the slope. Therefore, when we are quickly approaching our target, the derivative will slow us down to prevent overshoot.\n[/ordered-list-spaced-4]\n\n[grid:2]\n![Continuous tuned system response](/img/traction-control/image-209.png|400px|bg-white|Continuous tuning)\n![Discrete tuning step response](/img/traction-control/image-2010.png|400px|bg-white|Discrete Tuning)\n\n## Results\n\nBelow are my PID parameters I landed at. As you can see, I actually have 0 derivative because I chose a longer reaction time, meaning I wouldn't get a huge overshoot.\n\n![PID controller parameters](/img/traction-control/image-2011.png|336px|bg-white)\n\nThe algorithm is designed to only start going when we reach a slip HIGHER than our target slip. This is one way-way PID control because you don't really want the PID controller to unintentionally increase your torque when you aren't pressing the gas pedal to do so. I set the torque ramp to 5000Nm/s at first just to see the PID controller get to work. Formula cars take average of 2.5-3.0 seconds to go from rest to max speed, so it might even be 10x less for our car.\n\n![Scope showing slip ratio converging to target](/img/traction-control/image-2012.png|710px)\n\nAs you can see, we have no overshoot. We basically sit perfectly at 0.1 slip which is our target. I actually find the acceleration graphs to be quite interesting.\n\n[grid:2]\n![Vehicle acceleration scope](/img/traction-control/image-2013.png|384px||Vehicle Acceleration)\n![Wheel acceleration scope](/img/traction-control/image-2014.png|288px||Wheel Acceleration)\n\nAnyway, that's it! Next steps are testing it on the actual car. But this is a good starting point for tuning the PID controller on the real system.",
      "tags": ["engineering", "pid-control", "automotive", "fsae", "matlab", "simulink"],
      "readTime": "12 min read"
    },
    {
      "id": "uwfe-dashboard",
      "title": "UWFE Dashboard",
      "date": "2024-12-15",
      "author": "Emad Rahman",
      "excerpt": "A comprehensive dashboard for the University of Waterloo Formula Electric team, featuring real-time telemetry, data visualization, and team management tools.",
      "isNotionImport": true,
      "tags": ["web-development", "react", "dashboard", "fsae", "typescript"],
      "readTime": "8 min read"
    }
  ]
}


